/*
   This will process claims using  group information in the scope to determine the access token's
   permissions.

   How's it work?
   If the scope contains no group information, initial request may request and get the stored permissions in LDAP
   for the user. Subsequent exchanges/refreshes can specify more restrictive access.
   If the scope contains group information, (e.g.wlcg.groups:/group/path) then the same resolution is applied to
   group
*/
script_load('utils/init.qdl');


           fnal. := new_template('ldap');
   fnal.username := script_args(0);
   fnal.password := script_args(1);
  fnal.auth_type := 'simple';
    fnal.address := 'ldap-test.cilogon.org';
       fnal.port := 636;
 fnal.claim_name := 'uid';
fnal.search_base := 'ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
       fnal.type := 'ldap';
  fnal.ldap_name := VOP;

fnal.search_attributes. :=  [EPE];

       at_claims. := get_claims(fnal., claims.eppn); // test user

if[
    has_value('wlcg.groups:/dune/dunepro', scopes.);
  ][
   // Do lookup in LDAP.
    at_claims. := at_claims. ~ get_claims(fnal., 'dunepro@fnal.gov'); // Add DUNE records.
  ];

if[
   !is_defined(at_claims.eduPersonEntitlement.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities ==>  no scopes.
]; //end if

temp_scopes. := {};
       caps. := at_claims.eduPersonEntitlement.; // capabilities in claim source
// case 1: The handed in scopes are superstring of the capabilities. Return the capability
if[exec_phase == 'post_token'][temp_scopes. := sw(caps., scopes.);];

// case 2: The capabilities are superstring of the scopes. Return the scope.
if[exec_phase == 'post_refresh'][temp_scopes. := sw(scopes., caps.);];

access_token.scope := detokenize(unique(temp_scopes.), ' ', 2); // turn in to string, omit duplications, trailing space
