/*
   This script will pull information from a claim source and compute the resulting
   capabilities for the access token from that. Strategy is simple: Use the requested scopes
   as patterns. According to the WLCG and SciToken specs, an queried scope (e.g. write:/a/b/c/d)
   for which the requested scope is a head (e.g. write:/a/b) should be returned.
   updated: 2020-12-16T21:40:05.453Z


   Script for the client

 tokens{
  identity{
     type=identity
     qdl{
         load="qdl-vfs#/lib/fnal/fnal-idtoken.qdl"
         xmd={exec_phase="post_token"}
       }// end qdl
     } //end identity token
     access{
        type=wlcg
        issuer="https:cilogon.org"
        audience="https://wlcg.cern.ch/jwt/v1/any"
        lifetime=3600000
        qdl{
           load="qdl-vfs#/lib/fnal/fnal-at.qdl"
           xmd={exec_phase=["post_token","post_refresh"]}
           args=["USER_ID", "PASSWORD"]
        } //end QDL
     } // end access token
   } //end tokens

*/

DEBUG := true; // always false on production.
if[DEBUG][
//
/* Set up debug source from file for testing. */
//  f. := new_template('file');
//  f.file_path := '/home/ncsa/dev/ncsa-git/oa4mp/oa4mp-server-test-oauth2/src/main/resources/test-claims.json';
//  claims.eppn := 'jgaynor@fnal.gov';
//  at_claims. := get_claims(f. , claims.eppn);

/* ********** These fake getting the claims and scopes from the user. ********** */
    claims.eppn := 'swhite@fnal.gov';
    claims.uid := 'swhite@fnal.gov';
    scopes.0 := 'storage.create:/dune/';
    //scopes.0 := 'storage.write:/dune/scratch/users/swhite';
    scopes.1 :=  'storage.write:/dune/';
    // Give an extra long scope so it has to resolve it.
    scopes.2 := 'storage.create:/dune/scratch/users/swhite/temp';
]; // end debug block

if[
     script_args() != 2
  ]then[
     sys_err.ok := false;
     sys_err.message := 'Sorry, but you must supply both a username (principal) and password.';
     return();
  ];

           fnal. := new_template('ldap');
   fnal.username := script_args(0);
   fnal.password := script_args(1);
  fnal.auth_type := 'simple';
    fnal.address := 'ldap-test.cilogon.org';
       fnal.port := 636;
 fnal.claim_name := 'uid';
fnal.search_base := 'ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
       fnal.type := 'ldap';
  fnal.ldap_name := 'voPersonExternalID';

fnal.search_attributes. :=  ['eduPersonEntitlement'];

       at_claims. := get_claims(fnal., claims.eppn); // test user
 access_token.sub := claims.eppn;

// A 'starts with' function that returns the elements of x. that start with something in y.
// read 'x starts with y'

define[sw(x., y.)][return(mask(x., -1< list_starts_with(x., y.)));];

// Hop out if for some reason there were no scopes in LDAP.
if[
   !is_defined(at_claims.eduPersonEntitlement.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities ==>  no scopes.
]; //end if

temp_scopes. := {};
       caps. := at_claims.eduPersonEntitlement.; // capabilities in claim source
// case 1: The handed in scopes are superstring of the capabilities. Return the capability
if[exec_phase == 'post_token'][temp_scopes. := sw(caps., scopes.);];

// case 2: The capabilities are superstring of the scopes. Return the scope.
if[exec_phase == 'post_refresh'][temp_scopes. := sw(scopes., caps.);];

access_token.scope := detokenize(unique(temp_scopes.), ' ', 2); // turn in to string, omit duplications, trailing space

say(access_token.);

