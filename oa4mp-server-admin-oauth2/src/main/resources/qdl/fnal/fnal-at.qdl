/*
   This script will pull information from a claim source and compute the resulting
   capabilities for the access token from that. Strategy is simple: Use the requested scopes
   as patterns. According to the WLCG and SciToken specs, an queried scope (e.g. write:/a/b/c/d)
   for which the requested scope is a head (e.g. write:/a/b) should be returned.
   updated: 2020-12-16T21:40:05.453Z


   Script for the client

 tokens{
  identity{
     type=identity
     qdl{
         load="fnal/fnal-idtoken.qdl"
         xmd={exec_phase="post_token"}
       }// end qdl
     } //end identity token
     access{
        type=wlcg
        issuer="https:cilogon.org"
        audience="https://wlcg.cern.ch/jwt/v1/any"
        lifetime=3600000
        qdl{
           load="fnal/fnal-at.qdl"
           xmd={exec_phase=["post_token","post_refresh","post_exchange"]}
           args=["USER_ID", "PASSWORD"]
        } //end QDL
     } // end access token
   } //end tokens

*/
 acl_add('localhost:test/fnal');
 acl_add('fnal:dwd-7');
 acl_check();
 EPE := 'eduPersonEntitlement';


if[
     script_args() != 2
  ]then[
     sys_err.ok := false;
     sys_err.message := 'Sorry, but you must supply both a username (principal) and password.';
     return();
  ];

           fnal. := new_template('ldap');
   fnal.username := script_args(0);
   fnal.password := script_args(1);
  fnal.auth_type := 'simple';
    fnal.address := 'ldap-test.cilogon.org';
       fnal.port := 636;
 fnal.claim_name := 'uid';
fnal.search_base := 'ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
       fnal.type := 'ldap';
  fnal.ldap_name := 'voPersonExternalID';

fnal.search_attributes. :=  [EPE];

       at_claims. := get_claims(fnal., claims.eppn); // test user
 access_token.sub := claims.eppn;

// A 'starts with' function that returns the elements of x. that start with something in y.
// read 'x starts with y'


// Hop out if for some reason there were no scopes in LDAP.
if[
   !is_defined(at_claims.EPE.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities ==>  no scopes.
]; //end if


     temp_scopes. := {}; // result
requested_scopes. := {}; // which scope request to check
            caps. := at_claims.EPE.; // capabilities in claim source

   if[
        0 < size(tx_scopes.)
   ][
       requested_scopes. := tx_scopes.;
   ]else[
      requested_scopes. := scopes.;
   ];

// case 1: Query for available scopes. Return the capabilities requested.
if[
    exec_phase == 'post_token'
  ][
    temp_scopes. := resolve_templates(caps., requested_scopes., true);
  ];

// case 2: Actual scope request. Return the scope.

if[
    exec_phase == 'post_exchange' || exec_phase == 'post_refresh'
  ][
        temp_scopes. := resolve_templates(caps., requested_scopes., false);
  ];

 say('new scopes = ' + to_string(temp_scopes.));

// Debugging stuff
access_token.exp := access_token.iat + 543; // This is in seconds!!!
access_token.message := 'Testing new resolve template command. Setting AT lifetime to 543 sec.';

wlcg_scopes. := script_load('fnal/wlcg_cs.qdl', [script_args(0), script_args(1)]);

if[!sys_err.ok][return();]; // If there was an error, bail.

temp_scopes. := temp_scopes. ~ wlcg_scopes.;

access_token.scope := detokenize(unique(temp_scopes.), ' ', 2); // turn in to string, omit duplications, trailing space

say('***** QDL *****');
say(access_token.);
say('       caps = ' + to_string(caps.));
say('   tx_scope = ' + to_string(tx_scopes.));
say('tx_resource = ' + to_string(tx_resource.));
say('tx_audience = ' + to_string(tx_audience.));

