/*
   This script will pull information from a claim source and compute the resulting
   capabilities for the access token from that. Strategy is simple: Use the requested scopes
   as patterns. According to the WLCG and SciToken specs, an queried scope (e.g. write:/a/b/c/d)
   for which the requested scope is a head (e.g. write:/a/b) should be returned.
   updated: 2021-04-27T15:11:46.565Z


   Script for the client

 tokens{
  identity{
     type=identity
     qdl{
         load="fnal/fnal-idtoken.qdl"
         xmd={exec_phase="post_token"}
       }// end qdl
     } //end identity token
     access{
        type=wlcg
        issuer="https:cilogon.org"
        audience="https://wlcg.cern.ch/jwt/v1/any"
        lifetime=3600000
        qdl{
           load="fnal/fnal-at.qdl"
           xmd={exec_phase=["post_token","post_refresh","post_exchange"]}
           args=["USER_ID", "PASSWORD"]
        } //end QDL
     } // end access token
   } //end tokens

*/
 acl_add('localhost:test/fnal');
 acl_add('fnal:dwd-7');
 acl_check();
 EPE := 'eduPersonEntitlement';

if[
     script_args() != 2
  ]then[
     sys_err.ok := false;
     sys_err.message := 'Sorry, but you must supply both a username (principal) and password.';
     return();
  ];

           fnal. := new_template('ldap');
   fnal.username := script_args(0);
   fnal.password := script_args(1);
  fnal.auth_type := 'simple';
    fnal.address := 'ldap-test.cilogon.org';
       fnal.port := 636;
 fnal.claim_name := 'uid';
fnal.search_base := 'ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
       fnal.type := 'ldap';
  fnal.ldap_name := 'voPersonExternalID';

fnal.search_attributes. :=  [EPE,'isMemberOf'];

       at_claims. := get_claims(fnal., claims.eppn); // test user
 access_token.sub := claims.eppn;

// A 'starts with' function that returns the elements of x. that start with something in y.
// read 'x starts with y'


// Hop out if for some reason there were no scopes in LDAP.
if[
   !is_defined(at_claims.EPE.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities ==>  no scopes.
]; //end if

/*
   Variable score card
  ╔══════════════════╦════════════════════════════════════════════════════════════════════╗
  ║   output_scopes. ║   The output from this script, returned as access_token.scopes     ║
  ╠══════════════════╬════════════════════════════════════════════════════════════════════╣
  ║ requested_scopes.║   The scopes in this request. Note that in token exchanges         ║
  ║                  ║   there might be no such explicit requested tokens, so this will   ║
  ║                  ║   use the scopes in the initial request, stored in  scopes.        ║
  ╠══════════════════╬════════════════════════════════════════════════════════════════════╣
  ║       caps.      ║  Capabilities for this user stored in LDAP                         ║
  ╠══════════════════╬════════════════════════════════════════════════════════════════════╣
  ║   wlcg_scopes.   ║   Scopes stored as a WLCG capability set (CS). This may be empty   ║
  ║                  ║   and the requested CS must be in  caps. or an error is to be      ║
  ║                  ║   raised. Returned from wlcg_cs.qdl script.                        ║
  ║                  ║   N.B. These are added to the caps. variable as additional         ║
  ║                  ║   capabilites before processing.                                   ║
  ╠══════════════════╬════════════════════════════════════════════════════════════════════╣
  ║   scopes.        ║   The scopes of the initial request.                               ║
  ╚══════════════════╩════════════════════════════════════════════════════════════════════╝

*/
     output_scopes. := {}; // result
requested_scopes. := {}; // which scope request to check
            caps. := at_claims.EPE.; // capabilities in claim source

say('         caps = ' + to_string(caps.));
say('      scopes. ='  +  to_string(scopes., true));
 // requested_scopes. := 0 < size(tx_scopes.) ? tx_scopes. : scopes.;
if[
     0 < size(tx_scopes.)
  ][
    requested_scopes. := tx_scopes.;
  ]else[
   requested_scopes. := scopes.;
];


wlcg_scopes. := script_load('fnal/wlcg_cs.qdl', [script_args(0), script_args(1)]);

if[!sys_err.ok][return();]; // If there was an error, bail.

caps. := caps. ~ wlcg_scopes.;
say(' caps. =' + to_string(caps., true));
 wlcg_groups ='wlcg.groups';
 if[
    has_value(requested_scopes., wlcg_groups)
 ][
    if[
      is_defined(claims.isMemberOf)
      ][
       claims.wlcg_groups := claim.isMemberOf.;
       remove(claims.isMemberOf.);
    ];
 ];
// case 1: Query for available scopes. Return the capabilities requested.
if[
    exec_phase == 'post_token'
  ][
    output_scopes. := resolve_templates(caps., requested_scopes., true);
];

// case 2: Actual scope request. Return the scope.

if[
    exec_phase == 'post_exchange' || exec_phase == 'post_refresh'
  ][
        output_scopes. := resolve_templates(caps., requested_scopes., true);
];

 say('new output_scopes = ' + to_string(output_scopes.));

// Last thing: never return more than they initially asked for. So here this removes
// any scopes that does not st least start with one of the original scopes.

output_scopes. :=  mask(output_scopes., -1 < list_starts_with(output_scopes., scopes.));

access_token.scope := detokenize(unique(output_scopes.), ' ', 2); // turn in to string, omit duplications, trailing space

if[0<size(tx_audience.) || 0 < size(tx_resource.)][access_token.aud. := tx_audience.~tx_resource.;];

say('***** QDL *****');
say('        caps. ='  +  to_string(caps., true));
say(' wlcg_scopes. ='  +  to_string(wlcg_scopes., true));
say(' output_scopes. ='  +  to_string(output_scopes., true));
say('access_token. = ' +  to_string(access_token., true));
say('     tx_scope = ' +  to_string(tx_scopes.));
say('  tx_resource = ' +  to_string(tx_resource.));
say('  tx_audience = ' +  to_string(tx_audience.));