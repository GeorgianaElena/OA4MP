/*
   This script will pull information from a claim source and compute the resulting
   capabilities for the access token from that. Strategy is simple: The exact tokens
   allowed are in the source, so pass back those that match from the request.

   Script for the client

 tokens{
     access{
        type=wlcg
        issuer="https:cilogon.org"
        audience="https://wlcg.cern.ch/jwt/v1/any"
        lifetime=3600000
        qdl{
           load="fnal/fnal-at2.qdl"
           xmd={exec_phase=["post_token","post_refresh"]}
           args=["USER_ID", "PASSWORD"]
        } //end QDL
     } // end access token
   } //end tokens

*/

DEBUG := false; // always false on production.
if[DEBUG][
//
/* Set up debug source from file for testing. */
//  f. := new_template('file');
//  f.file_path := '/home/ncsa/dev/ncsa-git/oa4mp/oa4mp-server-test-oauth2/src/main/resources/test-claims.json';
//  claims.eppn := 'jgaynor@fnal.gov';
//  at_claims. := get_claims(f. , claims.eppn);

/* ********** These fake getting the claims and scopes from the user. ********** */
    claims.eppn := 'swhite@fnal.gov';
    claims.uid := 'swhite@fnal.gov';
    scopes.0 := 'storage.create:/dune';
    //scopes.0 := 'storage.write:/dune/scratch/users/swhite';
    scopes.1 :=  'storage.create:/dune/';
]; // end debug block

if[
     script_args() != 2
  ]then[
     sys_err.ok := false;
     sys_err.message := 'Sorry, but you must supply both a username (principal) and password.';
     return();
  ];

fnal. := new_template('ldap');
fnal.username := script_args(0);
fnal.password := script_args(1);
fnal.auth_type:='simple';
fnal.address:='ldap-test.cilogon.org';
fnal.port:=636;
fnal.claim_name:='uid';
fnal.search_base:='ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
fnal.type:='ldap';
fnal.ldap_name:='voPersonExternalID';
fnal.username:='uid=oa4mp_user,ou=system,o=Fermilab,o=CO,dc=cilogon,dc=org';

list_append(sa., 'eduPersonEntitlement');
fnal.search_attributes. := sa.;
at_claims. := get_claims(fnal., claims.eppn); // test user
say(at_claims., true);
// Get the claims. The capabilities are stored as a stem in

access_token.sub := claims.eppn;

if[
   !is_defined(at_claims.eduPersonEntitlement.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities, so no scopes.
]; //end if

caps. := at_claims.eduPersonEntitlement.; // capabilities in claim source

temp_scopes. := mask(caps., -1 < list_starts_with(caps., scopes.)); // take the ones that match the start
access_token.scope := detokenize(temp_scopes., ' ', 2); // turn in to string, omit trailing space
say(access_token.);

