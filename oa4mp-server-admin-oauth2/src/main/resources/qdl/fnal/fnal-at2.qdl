/*
   This script will pull information from a claim source and compute the resulting
   capabilities for the access token from that. Strategy is simple: Use the requested scopes
   as patterns. According to the WLCG and SciToken specs, an queried scope (e.g. write:/a/b/c/d)
   for which the requested scope is a head (e.g. write:/a/b) should be returned.
   updated: 2020-12-16T21:40:05.453Z


   Script for the client

 tokens{
  identity{
     type=identity
     qdl{
         load="fnal/fnal-idtoken.qdl"
         xmd={exec_phase="post_token"}
       }// end qdl
     } //end identity token
     access{
        type=wlcg
        issuer="https:cilogon.org"
        audience="https://wlcg.cern.ch/jwt/v1/any"
        lifetime=3600000
        qdl{
           load="fnal/fnal-at.qdl"
           xmd={exec_phase=["post_token","post_refresh","post_exchange"]}
           args=["USER_ID", "PASSWORD"]
        } //end QDL
     } // end access token
   } //end tokens

*/

DEBUG := true; // always false on production.
if[DEBUG][
   //
   /* Set up debug source from file for testing. */
   //  f. := new_template('file');
   //  f.file_path := '/home/ncsa/dev/ncsa-git/oa4mp/oa4mp-server-test-oauth2/src/main/resources/test-claims.json';
   //  claims.eppn := 'jgaynor@fnal.gov';
   //  at_claims. := get_claims(f. , claims.eppn);

   /* ********** These fake getting the claims and scopes from the user. ********** */
       claims.eppn := 'swhite@fnal.gov';
       claims.uid := 'swhite@fnal.gov';

]; // end debug block

if[
     script_args() != 2
  ]then[
     sys_err.ok := false;
     sys_err.message := 'Sorry, but you must supply both a username (principal) and password.';
     return();
  ];

           fnal. := new_template('ldap');
   fnal.username := script_args(0);
   fnal.password := script_args(1);
  fnal.auth_type := 'simple';
    fnal.address := 'ldap-test.cilogon.org';
       fnal.port := 636;
 fnal.claim_name := 'uid';
fnal.search_base := 'ou=people,o=Fermilab,o=CO,dc=cilogon,dc=org';
       fnal.type := 'ldap';
  fnal.ldap_name := 'voPersonExternalID';

fnal.search_attributes. :=  ['eduPersonEntitlement'];

       at_claims. := get_claims(fnal., claims.eppn); // test user
 access_token.sub := claims.eppn;

// A 'starts with' function that returns the elements of x. that start with something in y.
// read 'x starts with y'


// Hop out if for some reason there were no scopes in LDAP.
if[
   !is_defined(at_claims.eduPersonEntitlement.)
]then[
   access_token.scope := ''; // return empty scopes.
   return(); // nothing to do. No capabilities ==>  no scopes.
]; //end if


temp_scopes. := {};
       caps. := at_claims.eduPersonEntitlement.; // capabilities in claim source

// case 1: The handed in scopes are superstring of the capabilities. Return the capability
if[exec_phase == 'post_token'][temp_scopes. := resolve_templates(caps., scopes., false);];

// case 2: The capabilities are superstring of the scopes. Return the scope.
//if[exec_phase == 'post_refresh'][temp_scopes. := resolve_templates(caps., scopes., true);];

if[exec_phase == 'post_exchange' || exec_phase == 'post_refresh'][
   if[0 < size(tx_scopes.)
      ][
       temp_scopes. := resolve_templates(caps., tx_scopes., true);
     ]else[
       temp_scopes. := resolve_templates(caps., scopes., true);
     ];
  ];

access_token.scope := detokenize(unique(temp_scopes.), ' ', 2); // turn in to string, omit duplications, trailing space

// Debugging stuff
access_token.exp := access_token.iat + 543; // This is in seconds!!!
access_token.message := 'Testing new resolve template command. Setting AT lifetime to 543 sec.';

say('***** QDL *****');
say(access_token.);
say('caps.' + to_string(caps.));
say('tx_scope ' + to_string(tx_scopes.));
say('tx_resource ' + to_string(tx_resource.));
say('tx_audience ' + to_string(tx_audience.));

